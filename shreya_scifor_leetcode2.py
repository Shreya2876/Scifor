# -*- coding: utf-8 -*-
"""Shreya_Scifor_leetcode2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kOMkK0VmPu2UWpe9toYxXCjLvEYIXL2x
"""

from typing import List

class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        length = 0

        # Traverse the string from the end, skipping trailing spaces
        i = len(s) - 1
        while i >= 0 and s[i] == ' ':
            i -= 1

        # Count the characters of the last word
        while i >= 0 and s[i] != ' ':
            length += 1
            i -= 1

        return length


class Solution:
    def toLowerCase(self, s: str) -> str:
        return s.lower()


class Solution:
    def calPoints(self, operations: List[str]) -> int:
        lst=[]
        for i in operations:
            if i=="C":
                lst.pop()
            elif i=="D":
                lst.append(lst[-1]*2)
            elif i=="+":
                sm=lst[-2]+lst[-1]
                lst.append(sm)
            else:
                lst.append(int(i))
        print(lst)
        return sum(lst)


class Solution:
    def judgeCircle(self, moves: str) -> bool:
        steps = {
            'U': [0, -1],
            'D': [0, 1],
            'L': [1, -1],
            'R': [1, 1]
        }
        origin = [0, 0]

        for move in moves:
            dir, diff = steps[move]
            origin[dir]+= diff

        return origin[0] == origin[1] == 0

class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        n = 3
        rows, cols = [0] * n, [0] * n
        diag1 = diag2 = 0
        for index, move in enumerate(moves):
            i, j = move
            sign = 1 if index % 2 == 0 else -1
            rows[i] += sign
            cols[j] += sign
            if i == j:
                diag1 += sign
            if i + j == n-1:
                diag2 += sign
            if abs(rows[i]) == n or abs(cols[j]) == n or abs(diag1) == n or abs(diag2) == n:
                return 'A' if sign == 1 else 'B'
        return "Draw" if len(moves) == (n * n) else 'Pending'


class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        x, y, dx, dy = 0, 0, 0, 1
        for i in instructions:
            if i == 'R': dx, dy = dy, -dx
            if i == 'L': dx, dy = -dy, dx
            if i == 'G': x, y = x + dx, y + dy
        return (x, y) == (0, 0) or (dx, dy) != (0,1)


class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        wealth = list ()
        for i in accounts:
            wealth.append(sum(i))
        return max(wealth)


class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        ans = 0
        i, j = 0, 0
        def isValid(i, j): # to check co-ordinates
            return 0 <= i < len(mat) and 0 <= j < len(mat[0])

        while isValid(i, j):
            ans += mat[i][j]
            mat[i][j] = 0 # replace element with 0 to identify
            i += 1
            j += 1

        i, j = len(mat) - 1, 0

        while isValid(i, j): # secondary diagonal
            ans += mat[i][j]
            i -= 1
            j += 1

        return ans



class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []

        rows, cols = len(matrix), len(matrix[0])
        top, bottom, left, right = 0, rows-1, 0, cols-1
        result = []

        while len(result) < rows * cols:
            for i in range(left, right+1):
                result.append(matrix[top][i])
            top += 1

            for i in range(top, bottom+1):
                result.append(matrix[i][right])
            right -= 1

            if top <= bottom:
                for i in range(right, left-1, -1):
                    result.append(matrix[bottom][i])
                bottom -= 1

            if left <= right:
                for i in range(bottom, top-1, -1):
                    result.append(matrix[i][left])
                left += 1

        return result


class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:

        rows = set()
        cols = set()

        for row in range(len(matrix)):
            for col in range(len(matrix[row])):
                if matrix[row][col] == 0:
                    rows.add(row)
                    cols.add(col)

        for r in range(len(matrix)):
            for c in range(len(matrix[r])):
                if r in rows or c in cols:
                    matrix[r][c] = 0



class Solution(object):
    def countOdds(self, low, high):
        if(high%2==0 and low%2==0):
            return int((high-low)//2)
        elif(high%2!=0 and low%2!=0):
            return int(((high-low)+2)//2)
        else:
            return int(((high-low)+1)//2)


class Solution:
    def average(self, salary: List[int]) -> float:
        s = 0
        min_sal = 1000000
        max_sal = 0
        n= 0

        for i in salary:
            n+= 1
            s += i
            if min_sal>i:
                min_sal = i
            if max_sal< i:
                max_sal = i

        return (s-min_sal-max_sal)/(n-2)


class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        exchange = {5:0, 10:0}
        for bill in bills:
            if bill == 5 :
                exchange[5] +=1
            elif bill == 10 and exchange[5]:
                exchange[10] +=1
                exchange[5] -= 1
            elif bill == 20 and ((exchange[5] and exchange[10]) or exchange[5] >=3):
                if exchange[5] and exchange[10]:
                    exchange[5] -= 1
                    exchange[10] -=1
                else:
                    exchange[5] -=3
            else : return False
        return True



class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort(reverse = True)
        n=len(nums)
        for i in range(n-2):
            if nums[i]<nums[i+1]+nums[i+2]: return (nums[i]+nums[i+1]+nums[i+2])
        return 0



class Solution:
    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
        x1, y1 = coordinates[0]
        x2, y2 = coordinates[1]
        return all((y2 - y1) * (x - x1) == (x2 - x1) * (y - y1) for x, y in coordinates[2:])\


class Solution:
    def addBinary(self, a: str, b: str) -> str:
        carry = 0
        result = ''

        a = list(a)
        b = list(b)

        while a or b or carry:
            if a:
                carry += int(a.pop())
            if b:
                carry += int(b.pop())

            result += str(carry %2)
            carry //= 2

        return result[::-1]


class Solution:
    def multiply(self, num1: str, num2: str) -> str:

        sys.set_int_max_str_digits(10000)
        val1 = int(num1)
        val2 = int(num2)
        result = str(val1 *val2)
        return result




class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n < 0:
            return 1.0 / self.pow(x, -n)
        return self.pow(x, n)

    def pow(self, x: float, n: int) -> float:
        if n == 0:
            return 1.0
        if n % 2 == 0:
            return self.pow(x * x, n // 2)
        else:
            return x * self.pow(x * x, (n - 1) // 2)