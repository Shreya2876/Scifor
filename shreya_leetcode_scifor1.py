# -*- coding: utf-8 -*-
"""Shreya_leetcode_Scifor1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j8MXT8QOfaWPIZ34HoRFmqFc0xsCCG9P
"""

class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        merged = ''
        len1, len2 = len(word1), len(word2)
        i, j = 0, 0

        while i < len1 and j < len2:
            merged += word1[i] + word2[j]
            i += 1
            j += 1

        while i < len1:
            merged += word1[i]
            i += 1
        while j < len2:
            merged += word2[j]
            j += 1

        return merged

sol = Solution()
word1 = "abc"
word2 = "defgh"
result = sol.mergeAlternately(word1, word2)
print(result)

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        count_s = {}
        count_t = {}


        for char in s:
            count_s[char] = count_s.get(char, 0) + 1

        for char in t:
            count_t[char] = count_t.get(char, 0) + 1

        for char, count in count_t.items():
            if count_s.get(char, 0) != count:
                return char

sol = Solution()
s = "abcd"
t = "abcde"
result = sol.findTheDifference(s, t)
print(result)

class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        len_haystack, len_needle = len(haystack), len(needle)

        if len_needle == 0:
            return 0

        for i in range(len_haystack - len_needle + 1):
            if haystack[i:i + len_needle] == needle:
                return i


        return -1

sol = Solution()
haystack = "sadbutsad"
needle = "sad"
result = sol.strStr(haystack, needle)
print(result)

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        count_s = {}
        count_t = {}

        for char in s:
            count_s[char] = count_s.get(char, 0) + 1

        for char in t:
            count_t[char] = count_t.get(char, 0) + 1

        return count_s == count_t

sol = Solution()
s = "anagram"
t = "nagaram"
result = sol.isAnagram(s, t)
print(result)

class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        len_s = len(s)

        for substring_length in range(1, len_s // 2 + 1):
            if len_s % substring_length == 0:
                substring = s[:substring_length]
                repeated_string = substring * (len_s // substring_length)
                if repeated_string == s:
                    return True

        return False

sol = Solution()
s = "abab"
result = sol.repeatedSubstringPattern(s)
print(result)

from typing import List
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        non_zero_index = 0


        for i in range(len(nums)):

            if nums[i] != 0:
                nums[i], nums[non_zero_index] = nums[non_zero_index], nums[i]
                non_zero_index += 1
sol = Solution()
nums = [0, 1, 0, 3, 12]
sol.moveZeroes(nums)
print(nums)

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)
        carry = 1

        for i in range(n - 1, -1, -1):
            digits[i] += carry
            carry = digits[i] // 10
            digits[i] %= 10

        if carry:
            digits.insert(0, carry)

        return digits
sol = Solution()
digits = [1, 2, 3]
result = sol.plusOne(digits)
print(result)

class Solution:
    def arraySign(self, nums: List[int]) -> int:
        count_negative = 0
        has_zero = False

        for num in nums:
            if num == 0:
                has_zero = True
                break
            elif num < 0:
                count_negative += 1

        if has_zero:
            return 0
        elif count_negative % 2 == 0:
            return 1
        else:
            return -1

sol = Solution()
nums = [-1, -2, -3, -4, 3, 2, 1]
result = sol.arraySign(nums)
print(result)

class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()

        common_difference = arr[1] - arr[0]

        for i in range(1, len(arr)):
            if arr[i] - arr[i - 1] != common_difference:
                return False

        return True
sol = Solution()
arr = [3, 5, 1]
result = sol.canMakeArithmeticProgression(arr)
print(result)

class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        increasing = decreasing = True

        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                decreasing = False
            elif nums[i] < nums[i - 1]:
                increasing = False

        return increasing or decreasing
sol = Solution()
nums = [1, 2, 2, 3]
result = sol.isMonotonic(nums)
print(result)

class Solution:
    def romanToInt(self, s: str) -> int:
        roman_values = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }

        result = 0
        prev_value = 0

        for symbol in reversed(s):
            value = roman_values[symbol]

            if value < prev_value:
                result -= value
            else:
                result += value
            prev_value = value

        return result

sol = Solution()
print(sol.romanToInt("MCMXCIV"))